dp = [1]  # (0-indexed) 第i個元素代表0~10^(i+1)-1有幾個前綴1，也就是sigma j=0 to 10^(i+1)-1 G(j)
MOD = 998244353
j=10
k=1
for i in range(1000):
    dp.append(dp[i]+j+k)  # 找到的規律
    j*=10
    k=k*10+1
for i in range(len(dp)):
    dp[i]%=MOD
while 1:
    try:
        x=int(input())
        s=input()
    except EOFError:
        break
    if s[0] != '1':
        ans = dp[len(s)-1] % MOD
        print(ans)
    else:
        pos = -1
        for i in range(len(s)):
            if s[i] != '1':
                pos = i
                break
        ans = 0 if len(s) == 1 else dp[len(s)-2]
        if pos == -1:
            pos = len(s)-1
            ans += 1
        for i in range(1, pos+1):
            ans += int(s[i:])+1
        if int(s[pos]) > 1:
            ans += dp[len(s)-pos-1]
            if len(s)-pos-2 >= 0:  # 神奇的規律
                ans -= dp[len(s)-pos-2]
        ans %= MOD
        print(ans)
'''
首先先分析規律
範圍    值
0~10    1
0~100   12
0~1000  123
0~10000 1234
看到這裡我假設0~100000會等於12345，用程式驗證也正確，所以代表應該是一個有用的規律。
再來是會產生前綴1的數字只有1為最高位才會發生，所以最高位是2以上的數字他的值會等於0~10^(位數)的值。
接下來只剩下最高位為1的情況要判斷，這邊直接用例子來說好了。
假設要判斷1120
1.把0~999的值抓出來給ans(ans=123)
2.依序去掉最高位，直到最高位是不為1的數為止，並在過程中加總1的數量
  1120 去掉1 -> 120 ans+=120-0+1 (千位數1的總量)
  120 去掉1 -> 20 ans+=20-0+1 (百位數1的總量)
3.假設最高位大於1，就直接加總那一位數的1再減去再少一位數的1，如果最高位等於0，就代表那一位數之後的一定不會有任何的前綴1，所以回傳0
  20 -> 2 > 1 -> ans+=12-1 (12是0~99的所有前綴1的數量，1是0~9的所有前綴1的數量)
  ans=276
  個人不確定為什麼要減去少一位數的1的數量，是從規律中發現的。
另一個例子，判斷102
1.把0~99的值抓出來給ans(ans=12)
2.依序去掉最高位，直到最高位是不為1的數為止，並在過程中加總1的數量
  102 去掉1 -> 02 ans+=2-0+1 (百位數1的總量)
3.假設最高位大於1，就直接加總那一位數的1再減去再少一位數的1，如果最高位等於0，就代表那一位數之後的一定不會有任何的前綴1，所以回傳0
  0 -> 0 < 1 -> ans+=0
  ans=15 
在一個例子，判斷11111
1.把0~9999的值抓出來給ans(ans=1234)
2.依序去掉最高位，直到最高位是不為1的數為止，並在過程中加總1的數量
  11111 去掉1 -> 1111 ans+=1111-0+1 (萬位數1的總量)
  1111  去掉1 -> 111 ans+=111-0+1 (千位數1的總量)
  111   去掉1 -> 11 ans+=11-0+1 (百位數1的總量)
  11    去掉1 -> 1 ans+=1-0+1 (十位數1的總量)
  1     去掉1 -> 0 ans+=0-0+1 (個位數1的總量)
3.假設最高位大於1，就直接加總那一位數的1再減去再少一位數的1，如果最高位等於0，就代表那一位數之後的一定不會有任何的前綴1，所以回傳0
  0 -> 0 < 1 -> ans+=0
  ans=2473
  
'''
